<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="keywords" content="">

    <title>Neo4jMapper — The easiest way to map cypher values onto your entity models</title>

    <!-- Styles -->
    <link href="assets/css/page.min.css" rel="stylesheet">
    <link href="assets/css/prism.css" rel="stylesheet" />
    <link href="assets/css/barnardos.css" rel="stylesheet" />
    
    <!-- Favicons -->
    <link rel="apple-touch-icon" href="assets/img/apple-touch-icon.png">
    <link rel="icon" href="assets/img/favicon.png">

  </head>

  <body data-spy="scroll" data-target="#nav-scrollspy" data-offset="100" data-aos-easing="ease" data-aos-duration="1500"
    data-aos-delay="0" class="body-scrolled navbar-scrolled header-scrolled">

    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-light navbar-stick-dark" data-navbar="sticky">
      <div class="container">

        <div class="navbar-left">
          <button class="navbar-toggler" type="button">&#9776;</button>
          <a class="navbar-brand" href="index.html">
              <img class="logo-dark" src="assets/img/neo4j-mapper-logo-dark.png" alt="logo">
              <img class="logo-light" src="assets/img/neo4j-mapper-logo-light.png" alt="logo">
          </a>
        </div>

        <section class="navbar-mobile">
          <span class="navbar-divider d-mobile-none"></span>

          <nav class="nav nav-navbar">
            <a class="nav-link" href="index.html">Home</a>
            <a class="nav-link active" href="guide.html">Usage Guide</a>
            <a class="nav-link" href="examples.html">Examples</a>
            <a class="nav-link" href="download.html">Download</a>
            <a class="nav-link" href="support.html">Support</a>
            <a class="nav-link badge badge-success btn-barnardos" href="#barnardos-donate">Donate</a>
          </nav>
        </section>

      </div>
    </nav><!-- /.navbar -->


    <!-- Header -->
    <header class="header text-white pt-8 pb-6" style="background-image: url('/assets/img/graph.svg'),linear-gradient(to right, #68bbf4, #6dcc9c);background-repeat: no-repeat;background-position: 50% 50%;background-size: auto;">
      <div class="container">
        <h1 class="display-4">Neo4j<span class="font-weight-bold">Mapper &lt;&gt;</span></h1>
        <p class="lead-2 mt-6">The easiest way to map cypher values onto your entity models.</p>
      </div>
    </header><!-- /.header -->


    <!-- Main Content -->
    <main class="main-content">


      <!--
      |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
      | Populate the page
      |‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒‒
      !-->
      <section class="section">
        <div class="container">
          <div class="row mb-8">
            <div class="col-md-7 col-xl-8 mr-md-auto">
              <h1>Usage Guide</h1>
              <p>The following describes the features and APIs of Neo4jMapper. It does not describe in detail how to install, 
                configure or use Neo4j. For more information about Neo4j, please consult the Neo4j 
                <a href="https://neo4j.com/docs/">documentation</a>.
              </p>
              <p>Neo4jMapper uses <a href="https://github.com/neo4j/neo4j-dotnet-driver">Neo4j Driver</a> for all database 
                connections. Neo4jMapper has a dependency on this driver and installs the driver when the Neo4jMapper 
                <a href="https://www.nuget.org/packages/Neo4jMapper/">nuget</a> package is added to your project. You should consult 
                the driver <a href="https://neo4j.com/docs/driver-manual/current/">documentation</a> for instructions on how to 
                connect to the database and perform cypher queries.
              </p>
              <h2 id="getting-started">Getting Started</h2>
              <p>Ensure you have a working Neo4j database which can be downloaded from 
                <a href="https://neo4j.com/download/">here</a> and that you can connect to Neo4j's browser console at 
                <a href="http://localhost:7474/browser/">http://localhost:7474/browser/</a>.
              </p>
              <p>Create a new C# project and install Neo4jMapper as detailed <a href="download.html">here</a> and test the database
                connection using the <i>Hello World</i> example described in the Neo4j 
                <a href="https://neo4j.com/docs/driver-manual/current/get-started/">docs</a>.  
              </p>
              <p>Once you've connected to the database and can execute queries in code, you're ready to start writing applications
                using Neo4jMapper.
              </p>
              <h2 id="running-examples">Running Examples</h2>
              <p>The examples given through this guide use the movies database which can be accessed from the Neo4j 
                <a href="http://localhost:7474/browser/">browser</a> console.
              </p>
              <p>From the browser execute the following and step through the pages and run the Create script.</p>
              <pre><code class="language-none">
:play movie-graph
              </code></pre>
              <h2 id="working-with-neo4j-driver">Working with Neo4j Driver output</h2>
              <p><a href="https://github.com/neo4j/neo4j-dotnet-driver">Neo4j Driver</a> allows you to run queries synchronously 
                or asynchronously, both of which provide slightly different APIs due to the way .NET Framework deals with enumerated 
                results.
              </p>
              <h3>Synchronous Operations</h3>
              <pre><code class="language-csharp">
using (var driver = GraphDatabase.Driver("bolt://localhost:7687"))
{
  using (var session = driver.Session())
  {
    var result = session.Run(@"
      MATCH (person:Person)
      RETURN person
      LIMIT 1");

    foreach (var record in result)
    {
      Console.WriteLine(record.Values.Dump());
    }
  }
}
              </code></pre>
              <p>In this example, the <span class="badge badge-secondary">Run</span> method returns an 
                <a href="https://github.com/neo4j/neo4j-dotnet-driver/blob/1.7/Neo4j.Driver/Neo4j.Driver/V1/IStatementResult.cs">IStatementResult</a>
                object which provides us access to the records via the <i>IEnumerable&lt;IRecord&gt;</i>. As we enumerate 
                IStatementResult, each <a href="https://github.com/neo4j/neo4j-dotnet-driver/blob/1.7/Neo4j.Driver/Neo4j.Driver/V1/IRecord.cs">IRecord</a>
                provides us access to the record's query values, in this case, the <i>Person</i> node. The query values are returned 
                as an <i>IDictionary&lt;string, object&gt;</i> via the <span class="badge badge-secondary">Values</span> property.
              </p>
              <p>When we run this example, it outputs the query values to the console using 
                <a href="https://github.com/ServiceStack/ServiceStack.Text">ServiceStack.Text</a> <span class="badge badge-secondary">Dump</span> 
                method, which provides a handy JSON view of any .NET object or collection.
              </p>
              <pre><code class="language-json">
{
	person: 
	{
		__type: "Neo4j.Driver.Internal.Types.Node, Neo4j.Driver",
		Id: 1,
		Labels: 
		[
			Person
		],
		Properties: 
		[
			{
				Key: name,
				Value: Keanu Reeves
			},
			{
				Key: born,
				Value: 1964
			}
		]
	}
}
              </code></pre>
              <p>We can see that from the dictionary, one key/value pair was returned. The key 'person' matches the identifier name
                used in the query, and value is an object of type 
                <a href="https://github.com/neo4j/neo4j-dotnet-driver/blob/1.7/Neo4j.Driver/Neo4j.Driver/Internal/Types/Node.cs">Node</a>.
                When reading the Node's properties, we can see that it provides another dictionary: 
                <i>IReadOnlyDictionary&lt;string, object&gt;</i> via <span class="badge badge-secondary">Properties</span>. These
                are the actual node's property values. In this example they are returning the 'name' and 'born' values of the actor 
                'Keanu Reeves'.
              </p>
              <h3>Asynchronous Operations</h3>
              <pre><code class="language-csharp">
using (var driver = GraphDatabase.Driver("bolt://localhost:7687"))
{
  using (var session = driver.Session())
  {
    var cursor = await session.RunAsync(@"
      MATCH (movie:Movie)
      RETURN movie
      LIMIT 1");

    foreach (var record in await cursor.ToListAsync())
    {
      var output = record.Values.Dump();
      Console.WriteLine(output);
    }
  }
}
              </code></pre>
              <p>In this example, the awaitable <span class="badge badge-secondary">RunAsync</span> method returns an 
                <a href="https://github.com/neo4j/neo4j-dotnet-driver/blob/1.7/Neo4j.Driver/Neo4j.Driver/V1/IStatementResultCursor.cs">IStatementResultCursor</a>
                object which provides us access to the records via the awaitable 
                <span class="badge badge-secondary">ToListAsync</span> method, which returns us a <i>List&lt;IRecord&gt;</i>.
              </p>
              <div class="alert alert-info" role="alert">
                <p>You can see that IStatementResultCursor doesn't implement IEnumerable because yielding results from an 
                  enumerator is possible only synchronously in C# 7.
                </p>
              </div>
              <p>As before, when we enumerate the list, each IRecord provides us access to the record's query values, in this case,
                the <i>Movie</i> node. As before, the query values are returned as an <i>IDictionary&lt;string, object&gt;</i> via
                the <span class="badge badge-secondary">Values</span> property.
              </p>
              <pre><code class="language-json">
{
	movie: 
	{
		__type: "Neo4j.Driver.Internal.Types.Node, Neo4j.Driver",
		Id: 0,
		Labels: 
		[
			Movie
		],
		Properties: 
		[
			{
				Key: title,
				Value: The Matrix
			},
			{
				Key: tagline,
				Value: Welcome to the Real World
			},
			{
				Key: released,
				Value: 1999
			}
		]
	}
}                
              </code></pre>
              <p>We can see in the console output that one key/value pair was returned. The key 'movie' matches the identifier name
                used in the query, and value is the Node object and the Properties returns the node's property values. In this
                example they are returning the 'title', 'tagline' and 'released' values of 'The Matrix' movie.
              </p>
              <h2 id="mapping-records">Mapping Records</h2>
              <p>Now you can imagine, having to work directly with IStatementResult, IStatementResultCursor and IRecord would be
                tedious. Trying to extract values from these objects and assigning them to your models would result in a lot of 
                repetitive mapping code.
              </p>
              <p>Neo4jMapper is designed to reduce or eliminate this mapping code. It provides extension methods which take the 
                IStatementResult and IStatementResultCursor output and turns it into collections of entities. It does this by way 
                of a generic <i>Func</i> delegate which defines the .NET types that the cypher values should be converted to.
              </p>
              <div class="alert alert-info" role="alert">
                <p>We'll use async examples from this point forward as there's no difference in the way Neo4jMapper works whether 
                  you're writing synchronous or asynchronous code.
                </p>
                <p>For brevity, we'll also drop the driver initialization, session creation and console output steps.</p>
              </div>
              <h3 id="map-method">Map&lt;TReturn&gt; method</h3>
              <p>So let's re-visit the first example and use the <span class="badge badge-secondary">Map&lt;TReturn&gt;</span> 
                method to convert the person nodes to <i>Person</i> models.
              </p>
              <pre><code class="language-csharp">
var cursor = await session.RunAsync(@"
  MATCH (person:Person)
  RETURN person
  LIMIT 1");

var person = (await cursor.SingleAsync())
  .Map&lt;Person&gt;();
              </code></pre>
              <p>In this example, we're using the Neo4j Driver's <span class="badge badge-secondary">SingleAsync</span> extension 
                method as we're expecting only 1 result, so a single <i>IRecord</i> is given. Our 
                <span class="badge badge-secondary">Map&lt;TReturn&gt;</span> method takes <i>IRecord</i> and extracts the cypher
                value from the dictionary and converts it to <i>TReturn</i> type, which in this case is <i>Person</i> type.
              </p>
              <pre><code class="language-json">
{
  name: Keanu Reeves,
  born: 1964
}
              </code></pre>
              <h3 id="return-multiple-values">Returning multiple cypher values</h3>
              <p>This time we wish to query for the actor 'Cuba Gooding Jr.' and the first movie he acted in.</p>
              <pre><code class="language-csharp">
var cursor = await session.RunAsync(@"
  MATCH (actor:Person {name: 'Cuba Gooding Jr.'})-[:ACTED_IN]->(movie:Movie)
  WITH actor, movie
  ORDER BY movie.released
  WITH actor, collect(movie) AS movies
  RETURN actor, head(movies) AS firstMovie");

var actorWithMovie = (await cursor.SingleAsync())
  .Map((Person actor, Movie firstMovie) => new
  {
    Actor = actor,
    FirstMovie = firstMovie
  });
              </code></pre>
              <p>In this example, we're using the <span class="badge badge-secondary">Map&lt;TValue1, TValue2, TReturn&gt;</span> 
                method which requires you to declare the two input types we're expecting from the cypher values and the return type.
               </p>
              <p>The order of <i>TValue1</i> and <i>TValue2</i> is important. It should follow the same order as the cypher <i>RETURN</i>
                statement. So in our example, <i>TValue1</i> is of type <i>Person</i> and <i>TValue2</i> is of type <i>Movie</i>.
                The <i>TReturn</i> type in this example is an anonymous type, and here we just collect the <i>Person</i> and
                <i>Movie</i> values.
              </p>
              <pre><code class="language-json">
{
	Actor: 
	{
		name: Cuba Gooding Jr.,
		born: 1968
	},
	FirstMovie: 
	{
		title: A Few Good Men,
		tagline: "In the heart of the nation's capital, in a courthouse of the U.S. government, one man will stop at nothing to keep his honor, and one will stop at nothing to find the truth.",
		released: 1992
	}
}
              </code></pre>
              <h3 id="returning-lists">Returning lists</h3>
              <p>So far we have been returning only a single record with one or more cypher values, however, it is more typical
                to return a list of values and have these converted to a list of .NET types. Neo4jMapper provides 
                <span class="badge badge-secondary">Map</span> methods which work with lists the same as with single records.
              </p>
              <p>This time we wish to query for the 2 oldest actors and for each, return their most recent movie.</p>
              <pre><code class="language-csharp">
var cursor = await session.RunAsync(@"
  MATCH (actor:Person)
  WITH actor
  ORDER BY actor.born
  LIMIT 2
  MATCH (actor)-[:ACTED_IN]->(movie:Movie)
  WITH actor, movie
  ORDER BY movie.released DESC
  WITH actor, collect(movie) AS movies
  RETURN actor, head(movies) AS newestMovie");

var actorWithMovies = (await cursor.ToListAsync())
  .Map((Person actor, Movie newestMovie) => new
  {
    Actor = actor,
    NewestMovie = newestMovie
  }).ToList();
              </code></pre>
              <p>Because we're expecting to receive a list of results, this time we'll use the Neo4j Driver 
                <span class="badge badge-secondary">ToListAsync</span> method to return a list of <I>IRecord</I> objects. To convert these
                to .NET types we'll use the <span class="badge badge-secondary">Map&lt;TValue1, TValue2, TReturn&gt;</span> method which
                takes an <i>IEnumerable&lt;IRecord&gt;</i> and returns an <i>IEnumerable&lt;TReturn&gt;</i>. Again, we'll define an
                anonymous type for <i>TReturn</i> and this time return the converted values as a list.
              </p>
              <pre><code class="language-json">
[
	{
		Actor: 
		{
			name: Gene Hackman,
			born: 1930
		},
		NewestMovie: 
		{
			title: The Replacements,
			tagline: "Pain heals, Chicks dig scars... Glory lasts forever",
			released: 2000
		}
	},
	{
		Actor: 
		{
			name: Max von Sydow,
			born: 1929
		},
		NewestMovie: 
		{
			title: Snow Falling on Cedars,
			tagline: First loves last. Forever.,
			released: 1999
		}
	}
]
              </code></pre>
              <h3 id="supported-types">Supported .NET types</h3>
              <p>Whether working with single records or lists, Neo4jMapper's <span class="badge badge-secondary">Map</span> method allows a
                cypher statement to return up to 16 cypher values or fields. Each cypher value can be one of the supported .NET types
                which includes:
                <ul>
                  <li>CLR data types such as <i>bool</i>, <i>int</i>, <i>string</i> that are natively supported by <a href="https://github.com/neo4j/neo4j-dotnet-driver#value-types">Neo4j</a>.</li>
                  <li>Custom types such as <i>Person</i>, <i>Movie</i> etc.</li>
                  <li>Collection types such as <i>IEnumerable&lt;T&gt;</i>, <i>List&lt;T&gt;</i></li>
                </ul>
              </p>
              <p>When specifying the type to use in the <span class="badge badge-secondary">Map</span> method's <i>Func</i> input parameters,
                these must exactly match the expected type to be returned from the cypher values, otherwise, an exception is thrown in the mapper.
              </p>
              <p>The next rather contrived example returns some extra cypher values to demonstrate how they should be properly mapped.</p>
              <p>First, we've created a projection object to hold all our cypher values.</p>
              <pre><code class="language-csharp">
class Example6Projection
{
  public int NumberOfMovies { get; set; }
  public string ActorName { get; set; }
  public Person Actor { get; set; }
  public bool HasMovies { get; set; }
  public List&lt;Movie&gt; Movies { get; set; }
}
              </code></pre>
              <p>Now we'll construct a cypher query to return some additional data.</p>
              <pre><code class="language-csharp">
var cursor = await session.RunAsync(@"
  MATCH (actor:Person {name: 'Cuba Gooding Jr.'})-[:ACTED_IN]->(movie:Movie)
  WITH count(movie) as countOfMovies, actor.name as actorName, actor, COLLECT(movie) as movies
  RETURN countOfMovies, actorName, actor, size(movies) > 0 as hasMovies, movies");

var actorWithMovies = (await cursor.SingleAsync())
  .Map&lt;int, string, Person, bool, List&lt;Movie&gt;, Example6Projection&gt;(
    (numOfMovies, actorName, person, hasMovies, movies) => new Example6Projection
    {
      NumberOfMovies = numOfMovies,
      ActorName = actorName,
      Actor = person,
      HasMovies = hasMovies,
      Movies = movies
    });
              </code></pre>
              <p>As we can see, the <i>Func</i> input parameters exactly match and are in the same order as the <i>RETURN</i> statement
                cypher value list.
              </p>
              <pre><code class="language-json">
{
	NumberOfMovies: 4,
	ActorName: Cuba Gooding Jr.,
	Actor: 
	{
		name: Cuba Gooding Jr.,
		born: 1968
	},
	HasMovies: True,
	Movies: 
	[
		{
			title: What Dreams May Come,
			tagline: After life there is more. The end is just the beginning.,
			released: 1998
		},
		{
			title: Jerry Maguire,
			tagline: The rest of his life begins now.,
			released: 2000
		},
		{
			title: As Good as It Gets,
			tagline: A comedy from the heart that goes for the throat.,
			released: 1997
		},
		{
			title: A Few Good Men,
			tagline: "In the heart of the nation's capital, in a courthouse of the U.S. government, one man will stop at nothing to keep his honor, and one will stop at nothing to find the truth.",
			released: 1992
		}
	]
}
              </code></pre>
              <h3 id="unsupported-types">Unsupported .NET types</h3>
              <p>Practically all .NET clr types and custom types are supported, however, there are a few exceptions. Neo4j v3.4 introduced new
                temporal data types for working with date and time values, and Neo4j Driver introduced new .NET types to encapsulate these
                values, such as <a href="https://github.com/neo4j/neo4j-dotnet-driver/blob/1.7/Neo4j.Driver/Neo4j.Driver/V1/Types/ZonedDateTime.cs">ZonedDateTime</a>.
                Because of this, it is not directly possible to convert between <i>ZonedDateTime</i> and the .NET clr equivalent of <i>DateTimeOffset</i>
                when mapping custom types.
              </p>
              <pre><code class="language-csharp">
class Example7CustomType
{
  public DateTimeOffset TemporalValue { get; set; }
}

var cursor = await session.RunAsync(@"RETURN { temporalValue: datetime() } as map");

var customType = (await cursor.SingleAsync())
  .Map&lt;Example7CustomType&gt;();
              </code></pre>
              <p>The above code fails because the mapper is unable to automatically convert the incoming cypher <i>datetime</i> value which
              is returned as a <i>ZonedDateTime</i> to the equivalent .NET clr <i>DateTimeOffset</i>. The solution instead is to return
              the ZonedDateTime as-is.</p>
              <pre><code class="language-csharp">
class Example8CustomType
{
  public ZonedDateTime TemporalValue { get; set; }
}

var cursor = await session.RunAsync(@"RETURN { temporalValue: datetime() } as map");

var customType = (await cursor.SingleAsync())
  .Map&lt;Example8CustomType&gt;();
              </code></pre>
              <p>This works correctly and maps the native Neo4j Driver type.</p>
              <pre><code class="language-json">
{
	TemporalValue: 
	{
		Year: 2019,
		Month: 1,
		Day: 20,
		Hour: 5,
		Minute: 3,
		Second: 29,
		Nanosecond: 575000000,
		Zone: 
		{
			__type: "Neo4j.Driver.V1.ZoneOffset, Neo4j.Driver",
			OffsetSeconds: 0,
			Offset: PT0S
		},
		OffsetSeconds: 0
	}
}
              </code></pre>
              <div class="alert alert-info" role="alert">
                <p>There is a work-around using <a href="#custom-type-converters">Custom</a> Type Converters explained 
                  <a href="#custom-type-converters">later</a> in this guide.
                </p>
              </div>
              <h3 id="mapasync-methods">MapAsync Convenience Methods</h3>
              <p>Neo4jMapper provides some convenience methods to simplify mapping results when performing async operations.
              </p>
              <p><span class="badge badge-secondary">MapSingleAsync</span> method wraps a call to Neo4j Driver 
                <span class="badge badge-secondary">SingleAsync</span> followed by a call to <span class="badge badge-secondary">Map</span>
                for use when expecting exactly 1 row to be returned and mapped.
              </p>
              <p><span class="badge badge-secondary">MapAsync</span> iterates the results from <i>IStatementResultCursor</i> using Neo4j Driver 
                <span class="badge badge-secondary">FetchAsync</span> and for each result, calls <span class="badge badge-secondary">Map</span>
                method. This provides an efficient way of iterating a large dataset.
              </p>
              <p>The remainder of the usage guide will use the above convenience methods.</p>
              <h2 id="persisting-data">Persisting Data</h2>
              <p>So far we've only dealt with querying for cypher values. However, in any non-trivial application, we would want to create or
                update some records. The way we'd achieve this is through the use of <a href="https://neo4j.com/docs/cypher-manual/current/syntax/parameters/">parameters</a>.
              </p>
              <p>Similar to the way Neo4j Driver returns values as a dictionary, parameters are also constructed using a <i>Dictionary&lt;string, object&gt;</i>.
                In fact, Neo4j Driver already has good support for parameters, as long as we are passing simple values.
              </p>
              <p>We'll add an <a href="https://www.imdb.com/">IMDB</a> number to an existing movie.</p>
              <pre><code class="language-csharp">
class IMDBMovie : Movie
{
  public string imdb { get; set; }
}

var parameters = new Dictionary&lt;string, object&gt;
{
  {"imdb", "tt0133093"}
};

var cursor = await session.RunAsync(@"
  MATCH (movie:Movie {title: 'The Matrix'})
  SET movie.imdb = $imdb
  RETURN movie", parameters);

var updatedMovie = await cursor.MapSingleAsync&lt;IMDBMovie&gt;();
              </code></pre>
              <p>The newly added IMDB property is now returned in the model.</p>
              <pre><code class="language-json">
{
	imdb: tt0133093,
	title: The Matrix,
	tagline: Welcome to the Real World,
	released: 1999
}
              </code></pre>
              <h3 id="neo4jparameters">Neo4jParameters Object</h3>
              <p>For convenience, Neo4jMapper provides a handy <i>Neo4jParameters</i> object, which is just subclasses <i>Dictionary&lt;string, object&gt;</i>
                but arguably makes the code more readable.
              </p>
              <pre><code class="language-csharp">
var parameters = new Neo4jParameters
{
  {"titleSearch", "Top Gun"},
  {"imdb", "tt0092099"}
};

var cursor = await session.RunAsync(@"
  MATCH (movie:Movie {title: $titleSearch})
  SET movie.imdb = $imdb
  RETURN movie", parameters);

var updatedMovie = await cursor.MapSingleAsync&lt;IMDBMovie&gt;();
              </code></pre>
              <h3 id="parameter-maps">Parameter Maps</h3>
              <p>Setting single values is straightforward enough but what if you wanted to create or update an entire record? For instance,
                creating a movie? For this, Neo4jMapper provides an extension method <span class="badge badge-secondary">ToParameter</span>
                which takes a model and converts the public properties to key/value pairs and creates a map using the given key.
              </p>
              <p>We'll create a new movie object and convert it to a parameter map.</p>
              <pre><code class="language-csharp">
var movie = new IMDBMovie
{
  imdb = "tt0110912",
  released = 1994,
  tagline =
  "The lives of two mob hitmen, a boxer, a gangster's wife, and a pair of diner bandits intertwine in four tales of
    violence and redemption.",
  title = "Pulp Fiction"
};

var map = movie.ToParameter("newMovie");
              </code></pre>
              <p>Which returns a map with a key 'newMovie'.</p>
              <pre><code class="language-json">
{
	Key: newMovie,
	Value: 
	[
		{
			Key: imdb,
			Value: tt0110912
		},
		{
			Key: title,
			Value: Pulp Fiction
		},
		{
			Key: tagline,
			Value: "The lives of two mob hitmen, a boxer, a gangster's wife, and a pair of diner bandits intertwine in four tales of violence and redemption."
		},
		{
			Key: released,
			Value: 1994
		}
	]
}
              </code></pre>
              <h3 id="persisting-models">Persisting Models</h3>
              <p>Now that we can create parameter maps, we can use this in one of our fluent extension methods <span class="badge badge-secondary">WithEntity</span> 
                which takes an entity and converts it to a map.
              </p>
              <p>We'll now go ahead and create and persist a new movie.</p>
              <pre><code class="language-csharp">
var movie = new IMDBMovie
{
  imdb = "tt0110912",
  released = 1994,
  tagline =
    "The lives of two mob hitmen, a boxer, a gangster's wife, and a pair of diner bandits intertwine in four tales of
    violence and redemption.",
  title = "Pulp Fiction"
};

var parameters = new Neo4jParameters()
  .WithEntity("newMovie", movie);

var cursor = await session.RunAsync(@"
  CREATE (movie:Movie $newMovie)
  RETURN movie", parameters);

var createdMovie = await cursor.MapSingleAsync&lt;IMDBMovie&gt;();
              </code></pre>
              <p>Which returns us our new movie.</p>
              <pre><code class="language-json">
{
  imdb: tt0110912,
  title: Pulp Fiction,
  tagline: "The lives of two mob hitmen, a boxer, a gangster's wife, and a pair of diner bandits intertwine in four tales
  of violence and redemption.",
  released: 1994
}
              </code></pre>
              <h3 id="fluent-extensions">Parameters Fluent Extensions</h3>
              <p>Neo4jMapper provides a number of extension methods which help build up complex parameter sets. Each extension method takes
                the dictionary, adds one or more parameters, and returns the dictionary to allow chaining multiple methods.
                <table class="table table-striped">
                  <tr>
                    <th>Method Name</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>WithEntity</td>
                    <td>Creates a parameter map from a given entity model</td>
                  </tr>
                  <tr>
                    <td>WithEntities</td>
                    <td>Creates an array of parameter maps from a collection of given entity models</td>
                  </tr>
                  <tr>
                    <td>WithMap</td>
                    <td>Adds an existing map to the dictionary</td>
                  </tr>
                  <tr>
                    <td>WithMaps</td>
                    <td>Adds an existing map collection to the dictionary</td>
                  </tr>
                  <tr>
                    <td>WithParams</td>
                    <td>Builds a parameter map from anonymous type and infers keys from property names</td>
                  </tr>
                  <tr>
                    <td>WithValue</td>
                    <td>Adds a single value to the dictionary</td>
                  </tr>
                </table>
              </p>
              <h3 id="parameters-limitations">Limitations</h3>
              <p>When using <span class="badge badge-secondary">ToParameter</span> directly, or via 
                <span class="badge badge-secondary">WithEntity</span> method, the converter will only create valid key/value pairs (maps)
                from the root object properties. Any nested types, whether objects or collections, will not be converted correctly,
                resulting in exceptions thrown when trying to persist data. For this reason, it is advisable to mark any nested properties
                with <i>IgnoreDataMemberAttribute</i> to ensure they are ignored by the converter.
              </p>
              <p>The following provides an example of how to create a complex parameter list with ignored properties.</p>
              <pre><code class="language-csharp">
public class Person
{
  public string name { get; set; }
  public int born { get; set; }

  [IgnoreDataMember]
  public List&lt;Movie&gt; MoviesActedIn { get; set; }
}

var actorWithMovies = new Person
{
  name = "Samuel L. Jackson",
  born = 1948,
  MoviesActedIn = new List&lt;Movie&gt;
  {
    new Movie
    {
      released = 1994,
      tagline =
        "The lives of two mob hitmen, a boxer, a gangster's wife, and a pair of diner bandits intertwine in four tales of
        violence and redemption.",
      title = "Pulp Fiction"
    },
    new Movie
    {
      released = 1996,
      tagline =
        "A woman suffering from amnesia begins to recover her memories after trouble from her past finds her again.",
      title = "The Long Kiss Goodnight"
    },
    new Movie
    {
      released = 2000,
      tagline =
        "A man learns something extraordinary about himself after a devastating accident.",
      title = "Unbreakable"
    }
  }
};

var parameters = new Neo4jParameters()
  .WithEntity("newActor", actorWithMovies)
  .WithEntities("newMovies", actorWithMovies.MoviesActedIn);

await session.RunAsync(@"
  CREATE (person:Person $newActor)
  WITH person
  UNWIND $newMovies AS newMovie
  CREATE (person)-[:ACTED_IN]->(movie:Movie)
  SET movie = newMovie", parameters);
              </code></pre>
              <p>Here we can see that when we call <span class="badge badge-secondary">WithEntity</span> and pass our person model,
              <i>actorWithMovies</i>, the <i>MoviesActedIn</i> property is ignored when we create the map. We create a second map (or collection
                of maps) when we call <span class="badge badge-secondary">WithEntities</span> and pass our movie collection. This is 
                <i>UNWIND</i> in cypher to extract the map from the list when we create each movie node.
              </p>
              <h2 id="working-with-entities">Working with Entities</h2>
              <p>In a typical enterprise application, we would probably need to create, update, or even delete some records. In our movies
                examples, we may need to create a new movie and link it to an actor, or we may need to make a change to an existing movie,
                perhaps to add the IMDB number. In these cases, we'll need to access a node directly so that we can perform some change,
                or remove it, or modify its relationships.
              </p>
              <p>So far we've accessed individual records by performing a <i>MATCH</i> on some property. However, without using unique
                constraints, we can't assume there is only one record with the given property value. In cases like this, we may consider
                accessing the node by its id.
              </p>
              <p>Neo4jMapper provides an automatic way of mapping the node's id onto your model - we'll call it an entity from here - 
                so that we can make some changes to the entity in the application, and when performing updates, we can <i>MATCH</i>
                by the node id and be sure we're updating the same node we fetched.
              </p>
              <h3>NodeIdAttribute</h3>
              <p>Neo4jMapper provides a <i>NodeIdAttribute</i> which you can use to decorate a property in your entity with a type <i>long</i>.
                When a node is fetched and mapped, the node's id is automatically mapped to this property.
              </p>
              <p>In this example, we'll query a list of movies and then add an IMDB number to 'The Matrix' movie and update it by its node id.
              </p>
              <pre><code class="language-csharp">
public class MovieEntity
{
  [NodeId]
  [IgnoreDataMember]
  public long id { get; set; }

  public string title { get; set; }
  public string tagline { get; set; }
  public int released { get; set; }

  public string imdb { get; set; }
}

var cursor = await session.RunAsync(@"
  MATCH (movie:Movie {released: $year})
  RETURN movie", new { year = 1999 });

var movies = await cursor.MapAsync&lt;MovieEntity&gt;();

var matrix = movies.Single(p => p.title == "The Matrix");
matrix.imdb = "tt0133093";

var updateParams = new Neo4jParameters()
  .WithEntity("updatedMovie", matrix)
  .WithValue("nodeId", matrix.id);

cursor = await session.RunAsync(@"
  MATCH (movie)
  WHERE id(movie) = $nodeId
  SET movie = $updatedMovie
  RETURN movie", updateParams);

var updatedMovie = await cursor.MapSingleAsync&lt;MovieEntity&gt;();
              </code></pre>
              <p>Notice that we've also added the <i>IgnoreDataMemberAttribute</i> to the <i>id</i> property, because when we convert
                the entity back into a map using <span class="badge badge-secondary">WithEntity</span> we don't want the id included
                in the map, otherwise it will get persisted as another property in the node. A node's id is not a property of a node.
              </p>
              <pre><code class="language-json">
{
	title: The Matrix,
	tagline: Welcome to the Real World,
	released: 1999,
	imdb: tt0133093
}
              </code></pre>
              <h3>Session &amp; Transaction Extension methods</h3>
              <p>Now we have a way to map the node's id to an entity model and update the node by its id, we can simplify this further
                by using some basic <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> extension methods which
                fetch and update nodes by their id. Neo4jMapper provides the following methods.
                <table class="table table-striped">
                  <tr>
                    <th>Method Name</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>GetNode</td>
                    <td>Gets a node by the given node id and map to an entity model</td>
                  </tr>
                  <tr>
                    <td>GetNodeAsync</td>
                    <td>Gets a node by the given node id and map to an entity model</td>
                  </tr>
                  <tr>
                    <td>SetNode</td>
                    <td>Sets (overwrites) a node by the given node id</td>
                  </tr>
                  <tr>
                    <td>SetNodeAsync</td>
                    <td>Sets (overwrites) a node by the given node id</td>
                  </tr>
                </table>
              </p>
              <p>We'll repeat the above example using the extension methods.</p>
              <pre><code class="language-csharp">
var cursor = await session.RunAsync(@"
  MATCH (movie:Movie {released: $year})
  RETURN movie", new { year = 1999 });

var movies = (await cursor.ToListAsync())
  .Map&lt;MovieEntity&gt;();

var matrix = movies.Single(p => p.title == "The Matrix");
matrix.imdb = "tt0133093";

await session.SetNodeAsync(matrix);

var updatedMovie = await session.GetNodeAsync&lt;MovieEntity&gt;(matrix.id);
              </code></pre>
              <h2 id="advanced-mapping">Advanced Mapping</h2>
              <p>Under normal circumstances, the <span class="badge badge-secondary">Map</span> and 
                <span class="badge badge-secondary">WithEntity</span> methods cover most mapping requirements, however on occasion, you may need
                more control over mapping, and for this, we can use <a href="https://github.com/ServiceStack/ServiceStack.Text">ServiceStack.Text</a>
                directly. The <span class="badge badge-secondary">Map</span> method, via <i>ValueMapper</i> class, calls ServiceStack's 
                <span class="badge badge-secondary">FromObjectDictionary</span> method, and <span class="badge badge-secondary">WithEntity</span>
                and other extension methods call ServiceStack's <span class="badge badge-secondary">ToObjectDictionary</span> method.
              </p>
              <p>In addition to these methods, <a href="https://github.com/ServiceStack/ServiceStack.Text">ServiceStack.Text</a> provides an array
                of helpers, utilities and extension methods to cover practically all mapping & conversion use-cases, as well as JSON and CSV
                serializers.
              </p>
              <p>In particular, the <span class="badge badge-secondary">ConvertTo&lt;T&gt;</span> may be useful when mapping between entity 
                models and viewmodels. It works similar to <a href="https://automapper.org/">AutoMapper</a> in that it copies all matching object parameters.
                And as with all other mapping methods, <span class="badge badge-secondary">ConvertTo&lt;T&gt;</span> uses optimised reflection-based mapping to provide the highest performance.
              </p>
              <h3 id="custom-type-converters">Custom Type Converters</h3>
              <p>As mentioned earlier, one of the limitations of Neo4jMapper is its inability to directly map between Neo4j Driver's new
                temporal types such as <a href="https://github.com/neo4j/neo4j-dotnet-driver/blob/1.7/Neo4j.Driver/Neo4j.Driver/V1/Types/ZonedDateTime.cs">ZonedDateTime</a> 
                and <i>DateTimeOffset</i>, for example.
              </p>
              <p>For this, we can use Custom Type Converters. This is a new ServiceStack.Text feature which enables the developer to write a converter
                that takes any .NET type and converts it to a different .NET type. These converters are registered in ServiceStack.Text, and when a mapping
                operation detects source & target types defined in the converter, then this converter is invoked.
              </p>
              <p>Neo4jMapper provides type converters for mapping between most of the new temporal types, and .NET clr equivalents. To register all custom
                type converters simply call <span class="badge badge-secondary">Neo4jMapperConfig.RegisterTypeConverters</span> method. Alternatively,
                individual registrations are possible, or you can even register your own.
                <table class="table table-striped">
                  <tr>
                    <th>Method Name</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>RegisterLocalDateToDateTimeConverter</td>
                    <td>Converts between LocalDate and DateTime</td>
                  </tr>
                  <tr>
                    <td>RegisterLocalTimeToTimeSpanConverter</td>
                    <td>Converts between LocalTime and TimeSpan</td>
                  </tr>
                  <tr>
                    <td>RegisterZonedDateTimeToDateTimeOffsetConverter</td>
                    <td>Converts between ZonedDateTime and DateTimeOffset</td>
                  </tr>
                  <tr>
                    <td>RegisterLocalDateTimeToDateTimeConverter</td>
                    <td>Converts between LocalDateTime and DateTime</td>
                  </tr>
                </table>
              </p>
              <p>All of these use ServiceStack.Text <span class="badge badge-secondary">AutoMappingUtils.RegisterConverter</span> to easily
                configure and register your own converters.
              </p>
              <h3>Limitations</h3>
              <p>Although the supplied type converters are bi-directional (each registration method registers two converters to convert each way) 
                conversion does not work when mapping entity models back to parameters. The reason for this is that for the converter to work,
                the source and target types must both be known. When a node is mapped to an entity, we can read the source type from the
                dictionary, and we know the target type defined in the entity model, then the conversion works. But when we convert an entity model 
                back to a parameter map, we only know source type. We cannot infer the target type (the node's property) from anywhere.
              </p>
              <p>For this reason, we suggest wherever possible to use Neo4j Driver temporal types instead of .NET clr types. If this is not
                possible then define the entity model using the temporal type, and create an equivalent 
                <a href="https://en.wikipedia.org/wiki/Data_transfer_object">DTO</a> using the .NET clr type, and use ServiceStack.Text
                <span class="badge badge-secondary">ConvertTo&lt;T&gt;</span> to bi-directionally convert between the entity and DTO.
                That way the custom type converters will work correctly.
              </p>
              <hr>
              <h5>About Neo4jMapper</h5>
              <p class="lead">This software is developed and maintained by the Barnardos Australia software development <a href="https://github.com/barnardos-au">team</a>,
                as a voluntary effort. If you find this software
                useful, please consider making a donation to Barnardos Australia using the links below.<br> Thank you.
              </p>
            </div>

            <!-- Sidebar -->
            <div class="col-md-4 col-xl-3 d-none d-md-block">
              <aside class="sidebar sidebar-sticky stick" style="width: 255px;">
                <h6 class="sidebar-title">Contents</h6>
                <nav id="nav-scrollspy" class="nav flex-column">
                  <a class="nav-link" href="#getting-started">Getting Started</a>
                  <a class="nav-link" href="#running-examples">Running Examples</a>
                  <a class="nav-link" href="#working-with-neo4j-driver">Working with Neo4j Driver output</a>
                  <a class="nav-link" href="#mapping-records">Mapping Records</a>
                  <a class="nav-link" href="#persisting-data">Persisting Data</a>
                  <a class="nav-link" href="#working-with-entities">Working with Entities</a>
                  <a class="nav-link" href="#advanced-mapping">Advanced Mapping</a>
                </nav>
              </aside>
            </div>

          </div>
          <div id="barnardos-donate" class="row">
            <div class="col-lg-8 mx-auto">
              <a href="https://www.barnardos.org.au">
                <img src="assets/img/barnardos-australia.png" alt="Barnardos Australia" class="barnardos-logo float-left">
              </a>
              <h6 class="barnardos-we-believe float-left mr-8">We believe in children.</h6>
              <a class="btn btn-success btn-lg btn-barnardos btn-barnardos-donate mt-2" href="https://donate.barnardos.org.au/donate-now/donate/">Donate Now</a>
            </div>
          </div>
        </div>
      </section>

    </main>


    <!-- Footer -->
    <footer class="footer">
      <div class="container">
        <div class="row gap-y align-items-center">

          <div class="col-6 col-lg-3">
            <a href="index.html"><img src="assets/img/neo4j-mapper-logo-dark.png" alt="logo"></a>
          </div>

          <div class="col-6 col-lg-3 text-right order-lg-last">
            <div class="social barnardos-social-media-icons">
              <a class="social-github" href="https://www.linkedin.com/company/barnardos-australia"><i class="fa fa-linkedin"></i></a>
              <a class="social-twitter" href="https://twitter.com/barnardos_aus"><i class="fa fa-twitter"></i></a>
              <a class="social-twitter" href="https://www.facebook.com/BarnardosAustralia"><i class="fa fa-facebook"></i></a>
              <a class="social-twitter" href="https://instagram.com/barnardos_au/"><i class="fa fa-instagram"></i></a>
              <a class="social-twitter" href="https://www.youtube.com/user/barnardosaustralia/featured"><i class="fa fa-youtube"></i></a>
            </div>
          </div>

        </div>
      </div>
    </footer><!-- /.footer -->


    <!-- Scripts -->
    <script src="assets/js/page.min.js"></script>
    <script src="assets/js/prism.js"></script>

  </body>
</html>
